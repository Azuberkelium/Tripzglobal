<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zubi Merge</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            font-family: Arial, sans-serif;
            color: #333;
        }

        #game-container {
            text-align: center;
            background-color: #fff;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        canvas {
            border: 2px solid #333;
            background-color: #ccc;
        }

        #score-container {
            display: flex;
            justify-content: space-between;
            width: 402px;
            margin-top: 10px;
            font-size: 1.2em;
            font-weight: bold;
        }

        #tools-container {
            display: flex;
            justify-content: space-between;
            width: 402px;
            font-size: 1em;
            font-weight: bold;
        }

        #mission-container {
            margin-top: 10px;
            font-size: 1em;
        }

        #message {
            margin-top: 10px;
            font-size: 1.2em;
            color: #d9534f;
        }

        .button-group {
            margin-top: 15px;
            display: flex;
            justify-content: center;
            gap: 10px;
        }

        button {
            padding: 10px 20px;
            font-size: 1em;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            color: white;
            transition: background-color 0.3s;
        }

        #restart-button {
            background-color: #5cb85c;
        }

        #restart-button:hover {
            background-color: #4cae4c;
        }

        #hammer-button {
            background-color: #d9534f;
        }

        #hammer-button:hover {
            background-color: #c9302c;
        }

        #leaderboard-button {
            background-color: #5bc0de;
        }

        #leaderboard-button:hover {
            background-color: #31b0d5;
        }

        #revive-swap-button {
            background-color: #ffc107;
            color: black;
        }

        #revive-swap-button:hover {
            background-color: #e0a800;
        }
        
        #share-button {
            background-color: #007bff;
        }

        #share-button:hover {
            background-color: #0056b3;
        }
        
        #save-score-button {
            background-color: #28a745;
        }

        #save-score-button:hover {
            background-color: #218838;
        }

        #leaderboard-container {
            display: none;
            margin-top: 20px;
            width: 402px;
            text-align: left;
        }

        #leaderboard-container h2 {
            text-align: center;
        }

        #leaderboard-list {
            list-style-type: none;
            padding: 0;
        }

        #leaderboard-list li {
            padding: 8px;
            border-bottom: 1px solid #ddd;
            display: flex;
            justify-content: space-between;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <h1>Zubi Merge</h1>
        <div id="score-container">
            <div>Current Score: <span id="current-score">0</span></div>
            <div>Swaps: <span id="swaps-left">3</span></div>
        </div>
        <div id="tools-container">
            <div>Hammers: <span id="hammers-left">3</span></div>
            <button id="revive-swap-button">Revive Swap</button>
        </div>
        <div id="mission-container">
            Daily Mission: Merge the <span id="mission-target"></span> Zubi code!
        </div>
        <canvas id="gameCanvas" width="400" height="400"></canvas>
        <p id="message"></p>
        <div class="button-group">
            <button id="hammer-button">Hammer</button>
            <button id="restart-button">Start New Game</button>
            <button id="leaderboard-button">Leaderboard</button>
            <button id="share-button" style="display: none;">Share Score</button>
            <button id="save-score-button" style="display: none;">Save Score</button>
        </div>
        <div id="leaderboard-container">
            <h2>Leaderboard</h2>
            <ul id="leaderboard-list"></ul>
        </div>
    </div>

    <script type="module">
        // Import the functions you need from the SDKs you need
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-app.js";
        import { getAnalytics } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-analytics.js";
        import { getFirestore, collection, addDoc, query, orderBy, limit, getDocs } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-firestore.js";

        // Your web app's Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyAvROaZt0nui-hGlScU6scwNs1PZA2BRRU",
            authDomain: "tripz-2f46f.firebaseapp.com",
            projectId: "tripz-2f46f",
            storageBucket: "tripz-2f46f.firebasestorage.app",
            messagingSenderId: "145451108695",
            appId: "1:145451108695:web:75dd7c520a0e18e4e95612",
            measurementId: "G-79KHRS0HHS"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const analytics = getAnalytics(app);
        const db = getFirestore(app);

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('current-score');
        const swapsElement = document.getElementById('swaps-left');
        const hammersElement = document.getElementById('hammers-left');
        const messageElement = document.getElementById('message');
        const restartButton = document.getElementById('restart-button');
        const hammerButton = document.getElementById('hammer-button');
        const leaderboardButton = document.getElementById('leaderboard-button');
        const reviveSwapButton = document.getElementById('revive-swap-button');
        const shareButton = document.getElementById('share-button');
        const saveScoreButton = document.getElementById('save-score-button');
        const leaderboardContainer = document.getElementById('leaderboard-container');
        const leaderboardList = document.getElementById('leaderboard-list');
        const missionTargetElement = document.getElementById('mission-target');

        const GRID_SIZE = 4;
        const TILE_SIZE = canvas.width / GRID_SIZE;
        const FONT_SIZE_NUMBER = TILE_SIZE / 2;
        const FONT_SIZE_TEXT = TILE_SIZE / 6;
        let grid = [];
        let score = 0;
        let swaps = 3;
        let hammers = 3;
        let gameOver = false;
        let selectedTile = null;
        let hammerMode = false;
        let dailyMission = {};

        const zubiCodes = {
            '0': 'Happening', '1': 'How', '2': 'Zubi', '3': 'Baby', '4': 'Whatley',
            '5': 'Are', '6': 'You', '7': 'Hello', '8': 'What', '9': 'Is',
            '10': 'Goodbye', '20': 'Daylist', '25': 'Sorry', '30': 'Maths',
            '40': 'Stop', '43': 'Wow', '44': 'With', '45': 'Counting',
            '46': 'By', '47': 'Playtime', '48': 'Number', '49': 'Bed',
            '50': 'Go', '51': 'Dont', '59': 'Cuddles', '71': 'Or',
            '72': 'Yes', '73': 'No', '74': 'Why', '75': 'Please',
            '76': 'Calculator', '77': 'Countdown', '78': 'Count',
            '79': 'Down', '80': 'Up', '81': 'Can', '82': 'We',
            '83': 'Do', '84': 'That', '85': 'It\'s', '86': 'To',
            '87': 'Some', '88': 'Now', '89': 'My', '90': 'School',
            '91': 'Not', '92': 'Finished', '93': 'Code', '94': 'Talking',
            '95': 'In', '96': 'Circles', '97': 'Know', '98': 'Triangles',
            '99': 'Timer', '100': 'Love', '189': 'Mummy'
        };

        const codeValues = Object.keys(zubiCodes).map(Number);

        function getTileColor(value) {
            const colors = {
                0: '#EEE4DA', 1: '#EDE0C8', 2: '#F2B179', 3: '#F59563', 4: '#F67C5F',
                5: '#F65E3B', 6: '#EDCF72', 7: '#EDCC61', 8: '#EDC850', 9: '#EDC53F',
                10: '#EDC22E', 20: '#F2B179', 25: '#F59563', 30: '#F67C5F', 40: '#F65E3B',
                43: '#EDCF72', 44: '#EDCC61', 45: '#EDC850', 46: '#EDC53F', 47: '#EDC22E',
                48: '#EDC22E', 49: '#EDC22E', 50: '#F65E3B', 51: '#F65E3B', 59: '#EDCF72',
                71: '#EDCC61', 72: '#EDC850', 73: '#EDC53F', 74: '#EDC22E', 75: '#F2B179',
                76: '#F59563', 77: '#F67C5F', 78: '#F65E3B', 79: '#EDCF72', 80: '#EDCC61',
                81: '#EDC850', 82: '#EDC53F', 83: '#EDC22E', 84: '#F2B179', 85: '#F59563',
                86: '#F67C5F', 87: '#F65E3B', 88: '#EDCF72', 89: '#EDCC61', 90: '#EDC850',
                91: '#EDC53F', 92: '#EDC22E', 93: '#F2B179', 94: '#F59563', 95: '#F67C5F',
                96: '#F65E3B', 97: '#EDCF72', 98: '#EDCC61', 99: '#EDC850', 100: '#EDC53F',
                189: '#EDC22E'
            };
            return colors[value] || '#888';
        }

        function getFontColor(value) {
            return value > 4 ? '#f9f6f2' : '#776e65';
        }

        function generateDailyMission() {
            const lastMission = JSON.parse(localStorage.getItem('zubiMission'));
            const today = new Date().toDateString();

            if (lastMission && lastMission.date === today) {
                dailyMission = lastMission;
            } else {
                const missionCodes = [10, 20, 25, 30, 40, 43, 44, 45, 46, 47, 48, 49, 50, 51, 59, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100];
                const targetCode = missionCodes[Math.floor(Math.random() * missionCodes.length)];
                dailyMission = {
                    date: today,
                    target: targetCode,
                    completed: false
                };
                localStorage.setItem('zubiMission', JSON.stringify(dailyMission));
            }
            missionTargetElement.textContent = `${dailyMission.target} (${zubiCodes[dailyMission.target]})`;
        }

        function init() {
            grid = [];
            for (let i = 0; i < GRID_SIZE; i++) {
                grid[i] = [];
                for (let j = 0; j < GRID_SIZE; j++) {
                    grid[i][j] = 0;
                }
            }
            score = 0;
            swaps = 3;
            hammers = 3;
            gameOver = false;
            selectedTile = null;
            hammerMode = false;
            messageElement.textContent = '';
            showGame();
            updateScore();
            addRandomTile();
            addRandomTile();
            drawGrid();
            generateDailyMission();
            shareButton.style.display = 'none';
            saveScoreButton.style.display = 'none';

            // Check URL for shared score
            const urlParams = new URLSearchParams(window.location.search);
            const sharedScore = urlParams.get('score');
            if (sharedScore) {
                messageElement.textContent = `Someone shared their score with you! They scored ${sharedScore} points!`;
                shareButton.style.display = 'none';
                saveScoreButton.style.display = 'none';
            }
        }

        function updateScore() {
            scoreElement.textContent = score;
            swapsElement.textContent = swaps;
            hammersElement.textContent = hammers;
        }

        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    drawTile(i, j);
                }
            }
            if (selectedTile) {
                drawSelectionHighlight(selectedTile.x, selectedTile.y);
            }
            if (hammerMode) {
                drawHammerHighlight();
            }
        }

        function drawSelectionHighlight(x, y) {
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 5;
            ctx.strokeRect(x * TILE_SIZE + 2.5, y * TILE_SIZE + 2.5, TILE_SIZE - 5, TILE_SIZE - 5);
        }

        function drawHammerHighlight() {
            ctx.strokeStyle = '#d9534f';
            ctx.lineWidth = 5;
            ctx.strokeRect(2.5, 2.5, canvas.width - 5, canvas.height - 5);
        }

        function drawTile(x, y) {
            const value = grid[y][x];
            const codeText = zubiCodes[value.toString()] || '';

            ctx.beginPath();
            ctx.rect(x * TILE_SIZE + 2, y * TILE_SIZE + 2, TILE_SIZE - 4, TILE_SIZE - 4);
            ctx.fillStyle = getTileColor(value);
            ctx.fill();

            if (value !== 0) {
                ctx.fillStyle = getFontColor(value);
                ctx.font = `bold ${FONT_SIZE_NUMBER}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(value, x * TILE_SIZE + TILE_SIZE / 2, y * TILE_SIZE + TILE_SIZE / 2 - FONT_SIZE_TEXT / 2);

                ctx.fillStyle = getFontColor(value);
                ctx.font = `${FONT_SIZE_TEXT}px Arial`;
                ctx.fillText(codeText, x * TILE_SIZE + TILE_SIZE / 2, y * TILE_SIZE + TILE_SIZE / 2 + FONT_SIZE_NUMBER / 2 - FONT_SIZE_TEXT / 2);
            }
        }

        function addRandomTile() {
            const emptyTiles = [];
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    if (grid[i][j] === 0) {
                        emptyTiles.push({ y: i, x: j });
                    }
                }
            }

            if (emptyTiles.length > 0) {
                const randomTile = emptyTiles[Math.floor(Math.random() * emptyTiles.length)];
                const randomCodeIndex = Math.floor(Math.random() * 5);
                grid[randomTile.y][randomTile.x] = [0, 1, 2, 3, 4][randomCodeIndex];
            } else {
                checkGameOver();
            }
        }

        function checkGameOver() {
            let movesLeft = false;
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    if (grid[i][j] === 0) {
                        movesLeft = true;
                        break;
                    }
                }
                if (movesLeft) break;
            }

            if (!movesLeft) {
                for (let i = 0; i < GRID_SIZE; i++) {
                    for (let j = 0; j < GRID_SIZE; j++) {
                        const value = grid[i][j];
                        if (i + 1 < GRID_SIZE && grid[i + 1][j] === value) movesLeft = true;
                        if (j + 1 < GRID_SIZE && grid[i][j + 1] === value) movesLeft = true;
                        if (movesLeft) break;
                    }
                    if (movesLeft) break;
                }
            }

            if (!movesLeft && swaps === 0 && hammers === 0) {
                gameOver = true;
                messageElement.textContent = 'Game Over! No more moves or tools left.';
                addScoreToLeaderboard(score);
                shareButton.style.display = 'block';
                saveScoreButton.style.display = 'block';
            }
        }

        canvas.addEventListener('click', (event) => {
            if (gameOver || leaderboardContainer.style.display !== 'none') return;

            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((event.clientX - rect.left) / TILE_SIZE);
            const y = Math.floor((event.clientY - rect.top) / TILE_SIZE);

            if (hammerMode) {
                if (hammers > 0 && grid[y][x] !== 0) {
                    grid[y][x] = 0;
                    hammers--;
                    applyGravity();
                    checkForMerges();
                    addRandomTile();
                    drawGrid();
                }
                hammerMode = false;
                messageElement.textContent = '';
                updateScore();
                drawGrid();
            } else if (selectedTile) {
                const tile2 = { y: y, x: x };
                const isAdjacent = (Math.abs(selectedTile.x - tile2.x) <= 1 && selectedTile.y === tile2.y) ||
                                   (Math.abs(selectedTile.y - tile2.y) <= 1 && selectedTile.x === tile2.x);

                if (isAdjacent && swaps > 0) {
                    const temp = grid[selectedTile.y][selectedTile.x];
                    grid[selectedTile.y][selectedTile.x] = grid[tile2.y][tile2.x];
                    grid[tile2.y][tile2.x] = temp;
                    swaps--;
                    updateScore();
                    checkForMerges();
                    addRandomTile();
                    drawGrid();
                }

                selectedTile = null;
                drawGrid();

            } else {
                if (grid[y][x] !== 0) {
                    selectedTile = { y: y, x: x };
                    drawGrid();
                }
            }
        });

        function applyGravity() {
            for (let j = 0; j < GRID_SIZE; j++) {
                let writeIndex = GRID_SIZE - 1;
                for (let i = GRID_SIZE - 1; i >= 0; i--) {
                    if (grid[i][j] !== 0) {
                        grid[writeIndex][j] = grid[i][j];
                        if (writeIndex !== i) {
                            grid[i][j] = 0;
                        }
                        writeIndex--;
                    }
                }
            }
        }

        function checkForMerges() {
            let mergedThisTurn = false;
            let somethingChanged = true;

            while (somethingChanged) {
                somethingChanged = false;
                let potentialMerges = new Set();

                // Horizontal merges
                for (let i = 0; i < GRID_SIZE; i++) {
                    for (let j = 0; j < GRID_SIZE - 2; j++) {
                        if (grid[i][j] !== 0 && grid[i][j] === grid[i][j+1] && grid[i][j] === grid[i][j+2]) {
                            potentialMerges.add(`${i},${j}`);
                            potentialMerges.add(`${i},${j+1}`);
                            potentialMerges.add(`${i},${j+2}`);
                        }
                    }
                }

                // Vertical merges
                for (let i = 0; i < GRID_SIZE - 2; i++) {
                    for (let j = 0; j < GRID_SIZE; j++) {
                        if (grid[i][j] !== 0 && grid[i][j] === grid[i+1][j] && grid[i][j] === grid[i+2][j]) {
                            potentialMerges.add(`${i},${j}`);
                            potentialMerges.add(`${i+1},${j}`);
                            potentialMerges.add(`${i+2},${j}`);
                        }
                    }
                }

                if (potentialMerges.size > 0) {
                    somethingChanged = true;
                    mergedThisTurn = true;
                    const coords = [...potentialMerges].map(s => s.split(',').map(Number));
                    coords.forEach(([y, x]) => {
                        score += grid[y][x];
                        if (grid[y][x] === dailyMission.target && !dailyMission.completed) {
                            dailyMission.completed = true;
                            messageElement.textContent = 'Daily Mission Complete!';
                            localStorage.setItem('zubiMission', JSON.stringify(dailyMission));
                        }
                        grid[y][x] = 0;
                    });
                    applyGravity();
                }
            }

            if (mergedThisTurn) {
                updateScore();
            }
        }

        function addScoreToLeaderboard(newScore) {
            let scores = JSON.parse(localStorage.getItem('zubiLeaderboard')) || [];
            scores.push(newScore);
            scores.sort((a, b) => b - a);
            scores = scores.slice(0, 5);
            localStorage.setItem('zubiLeaderboard', JSON.stringify(scores));
        }

        async function getGlobalLeaderboard() {
            const scoresRef = collection(db, "leaderboard");
            const q = query(scoresRef, orderBy("score", "desc"), limit(5));
            const querySnapshot = await getDocs(q);
            const globalScores = [];
            querySnapshot.forEach((doc) => {
                globalScores.push(doc.data());
            });
            return globalScores;
        }

        async function displayLeaderboard() {
            const scores = await getGlobalLeaderboard();
            leaderboardList.innerHTML = '';
            if (scores.length === 0) {
                leaderboardList.innerHTML = '<li>No global scores yet!</li>';
            } else {
                scores.forEach((s, index) => {
                    const li = document.createElement('li');
                    li.textContent = `${index + 1}. ${s.name} - ${s.score}`;
                    leaderboardList.appendChild(li);
                });
            }
        }

        function showGame() {
            leaderboardContainer.style.display = 'none';
            canvas.style.display = 'block';
            document.getElementById('score-container').style.display = 'flex';
            document.getElementById('tools-container').style.display = 'flex';
            document.getElementById('mission-container').style.display = 'block';
            document.querySelector('.button-group').style.display = 'flex';
            drawGrid();
        }

        function showLeaderboard() {
            displayLeaderboard();
            leaderboardContainer.style.display = 'block';
            canvas.style.display = 'none';
            document.getElementById('score-container').style.display = 'none';
            document.getElementById('tools-container').style.display = 'none';
            document.getElementById('mission-container').style.display = 'none';
            document.getElementById('hammer-button').style.display = 'none';
            document.getElementById('revive-swap-button').style.display = 'none';
            document.getElementById('restart-button').style.display = 'block';
            document.getElementById('leaderboard-button').style.display = 'block';
        }

        restartButton.addEventListener('click', init);
        hammerButton.addEventListener('click', () => {
            if (gameOver || leaderboardContainer.style.display !== 'none') return;
            if (hammers > 0) {
                hammerMode = true;
                selectedTile = null;
                messageElement.textContent = 'Hammer mode active. Click a tile to remove it.';
                drawGrid();
            } else {
                messageElement.textContent = 'No hammers left!';
            }
        });

        reviveSwapButton.addEventListener('click', () => {
            if (gameOver || swaps >= 3) {
                messageElement.textContent = 'Cannot revive swaps right now.';
                return;
            }

            const activeTiles = [];
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    if (grid[i][j] !== 0) {
                        activeTiles.push({ y: i, x: j });
                    }
                }
            }

            if (activeTiles.length > 0) {
                const randomTile = activeTiles[Math.floor(Math.random() * activeTiles.length)];
                grid[randomTile.y][randomTile.x] = 0;
                swaps++;
                applyGravity();
                checkForMerges();
                updateScore();
                drawGrid();
                messageElement.textContent = 'One tile removed to revive a swap!';
            } else {
                messageElement.textContent = 'Not enough tiles to remove to revive a swap.';
            }
        });

        shareButton.addEventListener('click', () => {
            const currentUrl = window.location.href.split('?')[0];
            const shareUrl = `${currentUrl}?score=${score}`;
            navigator.clipboard.writeText(shareUrl).then(() => {
                messageElement.textContent = 'Score link copied to clipboard!';
            }).catch(err => {
                console.error('Failed to copy text: ', err);
                messageElement.textContent = 'Failed to copy link. Please try again.';
            });
        });

        saveScoreButton.addEventListener('click', async () => {
            const name = prompt("Enter your name for the leaderboard:");
            if (name) {
                try {
                    await addDoc(collection(db, "leaderboard"), {
                        name: name,
                        score: score,
                        timestamp: new Date()
                    });
                    messageElement.textContent = "Score saved! Check the leaderboard!";
                } catch (e) {
                    console.error("Error adding document: ", e);
                    messageElement.textContent = "Error saving score.";
                }
                saveScoreButton.style.display = 'none';
            }
        });

        leaderboardButton.addEventListener('click', () => {
            showLeaderboard();
        });

        init();
    </script>
</body>
</html>
